#+TITLE: generic collection interface for common lisp

* warning

  *DEVELOP BRANCH*
  these docs are not relevant to the develop branch.
  read the source & tests, or wait a few days.
  
  note that this is a work in progress, (version 0.1), and the
  interface (and some semantics) will change.This package is an
  implementation package, and exports many symbols. There are other
  packages under com.clearly-useful that provide smaller interfaces to
  be used ala carte (see below)

  work is also ongoing to bring basic clojure style reducers and folding
  to common lisp using lparallel, and some of the implementation of those
  will move to this package in the future, as well as some generic
  operations like conj & into, etc. long story short, the export list
  of this package is in flux, the only promise I can make at this
  point is that nothing exported will clash with cl.

* com.clearly-useful.generic-collection-interface

  a package for working with data structures generically in common
  lisp, inspired by clojure. the aim of this package is to provide
  simple protocols and a few generic functions that support working
  with data structures as abstractions, instead of writing to their
  specific implementations.

  there are many interesting data structure libraries written for
  common lisp, this package is an attempt to provide an interface
  simple and general enough that built in types and user types
  may be used interchangeably.  

  the abstractions are defined in one place so that they may
  interoperate cleanly. Any object implementing one of the three major
  protocols will have a default method to convert to the other
  two. see =base-cases.lisp= for details.

  Note that this package depends on version 0.1 of
  com.clearly-useful.protocols, which is not yet in quicklisp.
  
* the three major protocols

  This package defines three major protocols:
  =seq=, =associative=, =indexable=, and one
  minor protocol =countable=, which is required
  by =indexable=. Each of the major protocols
  may be implemented individually, and seperate systems
  are provided for each which define packages exporting
  only those symbols needed by the protocol.

  Implementations are provided for these protocols for the built-in
  collection types. See =builtins.lisp= for details.

** =seq=
   This protocol provides a list-like abstraction with
   the methods =head= and =tail=.

   see [[https://github.com/jaeschliman/com.clearly-useful.sequence-protocol][here]] for details.

** =associative=

   This protocol provides a dictionary-like abstraction with the
   methods =all-keys=, =all-values=, =contains-key-p=, and
   =value-for-key=.

   see [[https://github.com/jaeschliman/com.clearly-useful.associative-protocol][here]] for details. 
   
   
** =indexable=

   This protocol provides a vector-like abstraction, and depends on
   the =countable= protocol, which provides the methods =counted-p=
   and =count-elements=.  =indexable= itself defines one method,
   =element-at=
   
   see [[https://github.com/jaeschliman/com.clearly-useful.indexable-protocol][here]] for details.

* exported symbols

  See [[https://github.com/jaeschliman/com.clearly-useful.generic-collection-interface/blob/master/package.lisp][package.lisp]] for a list of all exported symbols.

  For in depth information each protocol and their associated symbols,
  visit the links to the individual protocol systems above.
  
* notes & todos

  the file test.lisp defines some data structures, each implementing
  one of the three major protocols & confirms that they translate
  among each other correctly.

** TODO fix warning on sbcl
   (doseq (x #(0 1 2) (* x x))
      (declare (type fixnum x)))
   is generating what appear to be useless type
   warnings at the moment. (with or without the declare)
** TODO fix hash-table weakness
   (empty h-t) not yet aware of hash table weakness
